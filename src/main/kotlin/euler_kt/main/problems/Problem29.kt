/*
 * This file is part of euler-kt
 * Copyright (C) 2024 Bill Kozak
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package euler_kt.main.problems

import euler_kt.main.framework.EulerProblem
import euler_kt.main.util.math.FactorizedBigInt
import euler_kt.main.util.primes.Precompute
import euler_kt.main.util.primes.Precompute.Companion.startPrimeListFromPrecompute
import euler_kt.main.util.primes.eratosthenesWithWheelFactorization

/*
The key idea is to factorize each number up to 100 into its prime factors.

From there, we can easily differentiate unique powers of numbers without having to actually perfom the exponentiation
(which would otherwise produce huge numbers, far too big to fit in any normal integer type).

From that point, there must be some other optimizations possible where we can compute the number of collisions which
will occur in the exponentiation, rather than even having to perform the exponentiation symbolically in the way
we do in this solution.
 */
class Problem29(override val defaultKeyParam: Int = 100) : EulerProblem<Int, Int> {
    override fun description(): String {
        return """
            Consider all integer combinations of a^b for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
            
            2^2=4, 2^3=8, 2^4=16, 2^5=32
            3^2=9, 3^3=27, 3^4=81, 3^5=243
            4^2=16, 4^3=64, 4^4=256, 4^5=1024
            5^2=25, 5^3=125, 5^4=625, 5^5=3125
            
            If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 
            distinct terms:
            
            4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
            
            How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
        """.trimIndent()
    }

    override fun validate(result: Number): Boolean {
        return result == 9183
    }

    override fun run(keyParam: Int): Int {

        val primes = primeList(keyParam)
        val baseTerms: MutableList<FactorizedBigInt> = mutableListOf()

        computeInitialTerms(FactorizedBigInt(), 0, primes, keyParam, baseTerms)

        val terms: MutableSet<FactorizedBigInt> = mutableSetOf()

        for(term in baseTerms) {
            for (i in 2..keyParam) {
                terms.add(term.pow(i))
            }
        }

        return terms.size
    }

    private fun primeList(keyParam: Int): List<Long> {
        return if(keyParam <= Precompute.largestPrime1024()) {
            startPrimeListFromPrecompute()
        } else {
            eratosthenesWithWheelFactorization(keyParam.toLong())
        }
    }

    private fun computeInitialTerms(
        prev: FactorizedBigInt,
        startIndex: Int,
        primes: List<Long>,
        keyParam: Int,
        output: MutableList<FactorizedBigInt>
    ) {
        for(i in startIndex until primes.size) {
            val prime = primes[i]
            val newFactor = prev.multiplyByPrime(prime)

            if(newFactor.longValue() > keyParam) {
                return
            }
            output.add(newFactor)
            computeInitialTerms(newFactor, i, primes, keyParam, output)
        }
    }
}